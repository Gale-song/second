[{
	"_id": "5e7b74e8f38f5d271c5e5a6f",
	"cr": "1.1",
	"col": 1,
	"row": 1,
	"keyword": "‘’",
	"msg": {
		"title": "web前端",
		"content": "基础内容是html+css+javascript"
	},
	"__v": 0
}, {
	"_id": "5e7b7509f38f5d271c5e5a70",
	"cr": "2.1",
	"col": 2,
	"row": 1,
	"keyword": "html’",
	"msg": {
		"title": "html",
		"content": "超文本标签语言"
	},
	"__v": 0
}, {
	"_id": "5e7b7676f6f5fa1ce4e42af7",
	"cr": "2.2",
	"col": 2,
	"row": 2,
	"keyword": "html",
	"msg": {
		"title": "标签",
		"content": "用来实现html页面中不同效果（大部分是显示效果）的子元素，多种不同的标签具有不同的功用"
	},
	"__v": 0
}, {
	"_id": "5e7b7713f6f5fa1ce4e42af8",
	"cr": "2.3",
	"col": 2,
	"row": 3,
	"keyword": "html’",
	"msg": {
		"title": "a标签",
		"content": "超链接标签，可以用来让文字或者图片实现页面跳转功能，可以通过自身href属性设置跳转目标"
	},
	"__v": 0
}, {
	"_id": "5e7b78eb4320ed277825daa7",
	"cr": "2.4",
	"col": 2,
	"row": 4,
	"keyword": "html",
	"msg": {
		"title": "列表标签",
		"content": "无序列表（ul）和有序列表（ol），常用的是无序列表，并且使用（list-style来设置列表前缀样式）"
	},
	"__v": 0
}, {
	"_id": "5e7b79c44320ed277825daa8",
	"cr": "2.5",
	"col": 2,
	"row": 5,
	"keyword": "html",
	"msg": {
		"title": "tab标签",
		"content": "表格标签，基本构成是table>tr>td，常用来做tab转换，也曾经被用来做页面布局，但是已经放弃这种布局方式"
	},
	"__v": 0
}, {
	"_id": "5e7b7a654320ed277825daa9",
	"cr": "2.6",
	"col": 2,
	"row": 6,
	"keyword": "html",
	"msg": {
		"title": "label标签",
		"content": "表单标签，通常用来作为input类标签的标注使用，让input类标签和文本内容融为一体，使用for属性指向input标签的id，以此来实现点击文本让input类标签获取焦点"
	},
	"__v": 0
}, {
	"_id": "5e7b7ba74320ed277825daaa",
	"cr": "2.7",
	"col": 2,
	"row": 7,
	"keyword": "html",
	"msg": {
		"title": "input标签",
		"content": "input标签是一类用来文本输入的标签，根据type属性的不同，可以被浏览器解释为text（文本输入框），password（密码输入框），checkbox（复选框），radio（单选按钮，需要注意的是，同一组的单选按钮应该具有相同的name属性），button（按钮），search（搜索框）等"
	},
	"__v": 0
}, {
	"_id": "5e7b7e84aefcc22a78716db5",
	"cr": "2.8",
	"col": 2,
	"row": 8,
	"keyword": "html",
	"msg": {
		"title": "input类标签",
		"content": "除了input标签外，还有一些其他类似的标签可以用来收集用户信息，select-option（下拉列表），textarea（文本域）等"
	},
	"__v": 0
}, {
	"_id": "5e7b7f89aefcc22a78716db6",
	"cr": "2.9",
	"col": 2,
	"row": 9,
	"keyword": "html",
	"msg": {
		"title": "form标签",
		"content": "表单标签，用来收集用户信息并提交，通过action属性设置提交表单时发送数据的目的地址，method属性设置发送数据的方式"
	},
	"__v": 0
}, {
	"_id": "5e7b8102aefcc22a78716db7",
	"cr": "2.10",
	"col": 2,
	"row": 10,
	"keyword": "html",
	"msg": {
		"title": "div标签",
		"content": "块级元素标签，经常被用来作为盒子，搭配css实现html页面的布局，"
	},
	"__v": 0
}, {
	"_id": "5e7b81e2aefcc22a78716db8",
	"cr": "2.11",
	"col": 2,
	"row": 11,
	"keyword": "html",
	"msg": {
		"title": "其他常用标签",
		"content": "span（行内标签），p（段落标签），b（加粗），i（斜体），s（删除线），u（下划线），strong（语义加粗），em（语义斜体），del（语义删除线），ins（语义下划线）"
	},
	"__v": 0
}, {
	"_id": "5e7b82f2aefcc22a78716db9",
	"cr": "3.1",
	"col": 3,
	"row": 1,
	"keyword": "css",
	"msg": {
		"title": "CSS",
		"content": "层叠样式表，用来为页面添加装饰效果，也可以用来做动画，主要特点是层叠，即是优先级高的先生效，同等优先级的后来者居上；CSS的使用有三种方式：1、内联样式表，2、内部样式表，3、外部样式表"
	},
	"__v": 0
}, {
	"_id": "5e7b83e2aefcc22a78716dba",
	"cr": "3.2",
	"col": 3,
	"row": 2,
	"keyword": "css",
	"msg": {
		"title": "CSS选择器",
		"content": "依据优先级的不同，分别是id选择器（#id），类选择器（.class），标签选择器（div）；符合选择器：交，并，后代，子代；伪类选择器：lvha"
	},
	"__v": 0
}, {
	"_id": "5e7b855baefcc22a78716dbc",
	"cr": "3.4",
	"col": 3,
	"row": 4,
	"keyword": "css",
	"msg": {
		"title": "一些css外观属性",
		"content": "color：设置字体颜色line-height：通过设置行高等于盒子高度可以让内容垂直居中text-align：设置文字对齐方式；text-indent：2em设置首行缩进text-decoration：normal，控制文本的修饰效果(下划线，删除线等)；list-style：none，删除列表标签的圆点"
	},
	"__v": 0
}, {
	"_id": "5e7b869daefcc22a78716dbd",
	"cr": "3.5",
	"col": 3,
	"row": 5,
	"keyword": "css",
	"msg": {
		"title": "display属性",
		"content": "通常用来设置元素的显示模式，block（块级元素），inline-block（行内块），inline（行内元素）；需要注意的是，行内块元素在和图片等其他内容在一行内显示的时候会默认具有垂直方向上基线对齐的属性，通过vertical-align来设置相关对齐方式；而对于行内元素，设置高和宽是没有意义的，水平方向的padding和margin可以设置，垂直方向的无效。"
	},
	"__v": 0
}, {
	"_id": "5e7bac80bfaff13798ef8665",
	"cr": "3.3",
	"col": 3,
	"row": 3,
	"keyword": "css",
	"msg": {
		"title": "字体样式",
		"content": "font-size（设置字体大小），font-family（设置字体的名称，多在字体图标中使用），font-weight：400（normal），700（bold），font-style（设置字体样式为斜体或者没有）"
	},
	"__v": 0
}, {
	"_id": "5e7cc01a3806b70d58cc886f",
	"cr": "3.6",
	"col": 3,
	"row": 6,
	"keyword": "css",
	"msg": {
		"title": "层叠的优先级",
		"content": "首先是继承样式的权重是最低的，即是说在嵌套结构中，不论父元素样式的权重有多大，子元素中继承的权重都为0000；!important命令具有最高的优先级；类和伪类的权重都是0010"
	},
	"__v": 0
}, {
	"_id": "5e7cc0743806b70d58cc8870",
	"cr": "3.7",
	"col": 3,
	"row": 7,
	"keyword": "css",
	"msg": {
		"title": "样式的继承",
		"content": "文字系列（font），列表系列（list），文本系列（text），元素可见性（visibility），光标属性（cursor），文本颜色（color），行高（line-height）"
	},
	"__v": 0
}, {
	"_id": "5e7cc218a0544a2ca8b39150",
	"cr": "3.8",
	"col": 3,
	"row": 8,
	"keyword": "css",
	"msg": {
		"title": "css背景设置",
		"content": "背景的符合写法background:背景颜色|背景图片|背景图片地址（url）|背景平铺方式（repeat）|背景滚动（fix）|背景位置（x|y）；示例background:url(123.jpg)|no-repeat|fixed|center|bottom;散装写法background-color（颜色），background-image（图片地址），background-repeat（平铺方式），background-position（背景图片的位置），background-attachment（设置背景滚动），background:rgba(0,0,0,.3)（设置背景透明）"
	},
	"__v": 0
}, {
	"_id": "5e7cc2f4a0544a2ca8b39151",
	"cr": "3.9",
	"col": 3,
	"row": 9,
	"keyword": "css",
	"msg": {
		"title": "border",
		"content": "边框设置，复合写法border:1px|solid|red，散装写法border-width（设置宽度），border-style（设置样式），border-color（设置颜色），border-radius（设置圆角边框）；拓展border-collapse:collapse赋值给table元素可以让table合并边框"
	},
	"__v": 0
}, {
	"_id": "5e7cc3bc7f0aa232fcdad479",
	"cr": "3.10",
	"col": 3,
	"row": 10,
	"keyword": "css",
	"msg": {
		"title": "边距",
		"content": "padding（内边距）会挤压盒子的内容，一次来实现视觉上的空隙，margin（外边距）会更改盒子之间的距离，以此来实现视觉上的空隙，但是，通常是使用padding来实现视觉效果，因为margin会造成不必要的麻烦"
	},
	"__v": 0
}, {
	"_id": "5e7cc4947f0aa232fcdad47a",
	"cr": "3.11",
	"col": 3,
	"row": 11,
	"keyword": "css",
	"msg": {
		"title": "margin的问题",
		"content": "上下相邻的两个块级元素分别设置了下外边距和上外边距的情况下，会产生外边距塌陷，两个外边距会转换为较大的一个外边距；而当子元素设置了上外边距之后，父元素会自动获取相同的上外边距，这就造成了父元素的位移，这种问题可以通过为父元素定义border或者上内边距来解决，但是更为常用的是使用overflow:hidden来实现BFC块级元素"
	},
	"__v": 0
}, {
	"_id": "5e7cc5577f0aa232fcdad47b",
	"cr": "3.12",
	"col": 3,
	"row": 12,
	"keyword": "css",
	"msg": {
		"title": "盒子的宽度",
		"content": "在默认的模式下，盒子宽度的计算式content’width+左右内边距+左右边框+左右外边距，不过，这是box-sizing:content-box默认模式下的宽度计算，设置border-box可以直接固定盒子的宽度"
	},
	"__v": 0
}, {
	"_id": "5e7cc62e7f0aa232fcdad47c",
	"cr": "3.13",
	"col": 3,
	"row": 13,
	"keyword": "css",
	"msg": {
		"title": "box-shadow",
		"content": "盒子阴影，复合写法box-shadow:h-shadow（水平阴影位置）|v-shadow（垂直阴影位置）|blur（模糊距离）|spread（阴影大小）|color（阴影颜色）|inset（设置阴影模式为内阴影/外阴影），其中前两个属性是必须的"
	},
	"__v": 0
}, {
	"_id": "5e7cc71f7f0aa232fcdad47d",
	"cr": "3.14",
	"col": 3,
	"row": 14,
	"keyword": "css",
	"msg": {
		"title": "float",
		"content": "浮动是使得元素脱标，到达父元素的指定位置上，方便内容的布置，经常用来使得ul中的li实现一行内显示，以此为基础制作轮播图；设置了浮动的元素会自动转化为行内块元素；浮动也会带来一系列的问题，因此就需要清除浮动带来的不利影响"
	},
	"__v": 0
}, {
	"_id": "5e7cc8307f0aa232fcdad47e",
	"cr": "3.15",
	"col": 3,
	"row": 15,
	"keyword": "css",
	"msg": {
		"title": "清除浮动",
		"content": "因为浮动的元素脱标，也就是不占据文档流中的位置，所以其他元素会挤占相应的位置，这就会造成浮动元素的父元素高度为0，从而导致布局失败，因此要清除浮动；1、在父元素中使用overflow:hidden来实现，2、伪元素实现清除浮动，其本质在于，在父元素的前后创建一个伪元素，在伪元素中使用clear:both来清除父元素前后的浮动影响"
	},
	"__v": 0
}, {
	"_id": "5e7cc8fc7f0aa232fcdad47f",
	"cr": "3.16",
	"col": 3,
	"row": 16,
	"keyword": "css",
	"msg": {
		"title": "position",
		"content": "定位是让元素可以在文档流中的任意位置出现，设置定位的元素也是脱标的（relative脱标但是仍旧占据位置），定位的元素自动转化为行内块元素，在定位中经常使用的是子绝父相；因为可能会有多个元素进行定位，所以可能会出现后来者居上的情况出现，通过z-index来设置叠放次序"
	},
	"__v": 0
}, {
	"_id": "5e7cc9687f0aa232fcdad480",
	"cr": "3.17",
	"col": 3,
	"row": 17,
	"keyword": "css",
	"msg": {
		"title": "元素的显示和隐藏",
		"content": "通过设置display:none可以隐藏对象，而block会显示元素，使用display的本质是设置元素是否被渲染；visibility:hidden也可以实现对象的隐藏，使用visibility:visible可以显示对象，不过这样做的元素总是被渲染了的（占据位置）"
	},
	"__v": 0
}, {
	"_id": "5e7cca177f0aa232fcdad481",
	"cr": "3.18",
	"col": 3,
	"row": 18,
	"keyword": "css",
	"msg": {
		"title": "overflow",
		"content": "设置元素的溢出隐藏模式，经常被用来清除浮动，或者是文本域的内容设置；visible（不设置隐藏），auto（自动显示滚动条），hidden（溢出隐藏），scroll（始终显示滚动条）"
	},
	"__v": 0
}, {
	"_id": "5e7ccb2f7f0aa232fcdad482",
	"cr": "3.19",
	"col": 3,
	"row": 19,
	"keyword": "css",
	"msg": {
		"title": "一些界面细节",
		"content": "cursor可以用来设置鼠标样式，default（默认），point（点击），move（移动），text（焦点光标）；outline经常用来设置input的外轮廓为none，outline:color|style|width；resize:none设置文本域不可拖拽；vertical-align经常用来设置内容中文字和图片的对齐方式（当然也可以设置文字和另外一个盒子的对齐方式）"
	},
	"__v": 0
}, {
	"_id": "5e7ccbd27f0aa232fcdad483",
	"cr": "3.20",
	"col": 3,
	"row": 20,
	"keyword": "css",
	"msg": {
		"title": "溢出文字隐藏",
		"content": "white-space设置内容文本的显示方式，通常用来设置强制一行内显示（nowrap）；text-overflow设置文本内容溢出时的显示方式，通常更改为省略号（ellipsis）；并用两者实现文本内容一行内显示"
	},
	"__v": 0
}, {
	"_id": "5e7ccc837f0aa232fcdad484",
	"cr": "3.21",
	"col": 3,
	"row": 21,
	"keyword": "css",
	"msg": {
		"title": "精灵图",
		"content": "本质是一张收容了大量背景图片的图片集合，在具体使用的过程中，通过background-position属性精准定位背景图片的位置，这么做可以有效的减少图片资源的加载，类似的字体图标也有这样的效果；注意，精灵图是可以进行缩放的，缩放后也可以进行定位，实现高清图片的加载"
	},
	"__v": 0
}, {
	"_id": "5e7cceae5cbae31010633d6f",
	"cr": "3.22",
	"col": 3,
	"row": 22,
	"keyword": "css",
	"msg": {
		"title": "字体图标",
		"content": "@font-face"
	},
	"__v": 0
}, {
	"_id": "5e7ccf0d5cbae31010633d70",
	"cr": "4.1",
	"col": 4,
	"row": 1,
	"keyword": "h5c3",
	"msg": {
		"title": "新标签",
		"content": "header（头部），nav（导航栏），footer（底部），article（文章标签），section（节，区段，类似div），aside（内容侧边）"
	},
	"__v": 0
}, {
	"_id": "5e7ccf715cbae31010633d71",
	"cr": "4.2",
	"col": 4,
	"row": 2,
	"keyword": "h5c3",
	"msg": {
		"title": "datalist",
		"content": "定义选项列表，和input标签一起使用，实现内容提示"
	},
	"__v": 0
}, {
	"_id": "5e7ccfbd5cbae31010633d72",
	"cr": "4.3",
	"col": 4,
	"row": 3,
	"keyword": "h5c3",
	"msg": {
		"title": "fieldset",
		"content": "将表单内的元素进行打包，搭配legend标签使用，会有标题框和边框"
	},
	"__v": 0
}, {
	"_id": "5e7cd0905cbae31010633d73",
	"cr": "4.4",
	"col": 4,
	"row": 4,
	"keyword": "h5c3",
	"msg": {
		"title": "新增input",
		"content": "新增的type属性值：email（邮箱格式），tel（手机号格式），url（输入url格式），number（数字格式），search（语义化搜索框），range（自由拖动的滑块）；新增的属性：placeholder（占位符），autofocus（自动获取焦点），autocomplete（自动补全，默认是on，表示显示），required（必填选项），accesskey（设置获取焦点的快捷键）"
	},
	"__v": 0
}, {
	"_id": "5e7cd0e05cbae31010633d74",
	"cr": "4.5",
	"col": 4,
	"row": 5,
	"keyword": "h5c3",
	"msg": {
		"title": "多媒体标签",
		"content": "embed（可以用来插入各种多媒体），audio（音频播放），video（视频播放），然而都没用处，兼容性很差，需要自己写"
	},
	"__v": 0
}, {
	"_id": "5e7cd23c5cbae31010633d75",
	"cr": "4.6",
	"col": 4,
	"row": 6,
	"keyword": "h5c3",
	"msg": {
		"title": "结构伪类选择器",
		"content": "结构伪类选择器:first-child（父元素的首个子元素），:last-child（父元素的最后一个元素），:nth-child(n)（父元素的第n个子元素），p:first-of-type（父元素中所有的p标签中的第一个，这个选择器会追踪标签的类型）"
	},
	"__v": 0
}, {
	"_id": "5e7cd29e5cbae31010633d76",
	"cr": "4.7",
	"col": 4,
	"row": 7,
	"keyword": "h5c3",
	"msg": {
		"title": "属性选择器",
		"content": "选取标签带有某些特殊属性的选择器，用“[]”来包裹属性，另外可以通过符号限定属性的值，div[class^=font]（以font为开始），div[class$=font]（以font为结束），div[class*=font]（包含font）"
	},
	"__v": 0
}, {
	"_id": "5e7cd3225cbae31010633d77",
	"cr": "4.8",
	"col": 4,
	"row": 8,
	"keyword": "h5c3",
	"msg": {
		"title": "伪元素选择器",
		"content": "伪元素选择器，重点是::before和::after；::first-letter（选中文本中的第一个单词/字），::first-line（选中文本的第一行），::selection（获取被选中的文本，可以更改相关样式）"
	},
	"__v": 0
}, {
	"_id": "5e7cd3ba5cbae31010633d78",
	"cr": "4.9",
	"col": 4,
	"row": 9,
	"keyword": "h5c3",
	"msg": {
		"title": "伪元素的使用",
		"content": "before和after伪元素的功能十分的强大，可以实现清除浮动，不影响页面布局的情况下添加新的标签（伪元素本质就是生成一个标签），使用字体图标等；需要注意的是，伪元素具有content属性，它必须被设置"
	},
	"__v": 0
}, {
	"_id": "5e7cd4365cbae31010633d79",
	"cr": "4.10",
	"col": 4,
	"row": 10,
	"keyword": "h5c3",
	"msg": {
		"title": "css3的盒模型",
		"content": "在默认情况下，css使用的盒模型是content-box（内容驱动），通过box-sizing:border-box设置盒模型为（边框驱动）"
	},
	"__v": 0
}, {
	"_id": "5e7cd67fb25021213881bab9",
	"cr": "4.11",
	"col": 4,
	"row": 11,
	"keyword": "h5c3",
	"msg": {
		"title": "transition",
		"content": "过渡可以实现属性的渐变，这个属性需要设置在需要进行变换的元素所在的css样式表中，transition:property（需要过渡的属性，常用）|duration（过渡动画进行的时间）|timing-function（动画曲线）|delay（延迟生效）"
	},
	"__v": 0
}, {
	"_id": "5e7cd9a0b25021213881baba",
	"cr": "4.12",
	"col": 4,
	"row": 12,
	"keyword": "h5c3",
	"msg": {
		"title": "2D变形",
		"content": "新增特性transform，可以实现元素的位移，旋转，倾斜，缩放；通常这些变形和transition一起使用实现过渡效果；transform:translate(x,y),translateX,translateY（位移）；transform:rotate(deg)（旋转，单位是角度）；transform:scale(x,y),scaleX,scaleY（倾斜）；transform:scale(x,y),scaleX,scaleY（缩放）；transform-origin（调整2D变形的源点；这些变形是可以复合写法的）"
	},
	"__v": 0
}, {
	"_id": "5e7cda51b25021213881babb",
	"cr": "4.13",
	"col": 4,
	"row": 13,
	"keyword": "h5c3",
	"msg": {
		"title": "3D变形",
		"content": "实现z坐标轴的变形效果，为了在2D平面上显示出3D效果，需要使用perspective:500来设置透视的距离，这个属性设置给父元素，可以被子元素继承；backface-visibility:hidden设置当元素不面向屏幕时是不可见的"
	},
	"__v": 0
}, {
	"_id": "5e7cdbf9b25021213881babc",
	"cr": "4.14",
	"col": 4,
	"row": 14,
	"keyword": "h5c3",
	"msg": {
		"title": "animation",
		"content": "css3动画的调用，需要声明动画函数，同样是浏览器渲染的动画效果；复合模式animation:name（动画名称）|duration（动画完成所需时间）|timing-function（动画曲线）|delay（延时生效）|iteration-count（动画播放次数，infinite表示不停循环）|direction（动画方向，alternate实现逆向播放）|play-state（动画阶段，paused表示暂停动画）|fill-mode（设置动画停止时元素保留的属性，forwards[保留动画结束时的属性]，backwards[保留元素的初始属性]）"
	},
	"__v": 0
}, {
	"_id": "5e7cdc39b25021213881babd",
	"cr": "4.15",
	"col": 4,
	"row": 15,
	"keyword": "h5c3",
	"msg": {
		"title": "css3动画的声明",
		"content": "@keyframe|animationName来声明动画"
	},
	"__v": 0
}, {
	"_id": "5e7ce804b25021213881babe",
	"cr": "4.16",
	"col": 4,
	"row": 16,
	"keyword": "h5c3",
	"msg": {
		"title": "flex布局",
		"content": "伸缩布局，通过主轴和侧轴来实现页面布局，通过display:flex来实现父元素的伸缩布局，然后子元素中使用flex:n来声明子元素占有的份数（这个份数是根据父元素的宽度来自动分配的）；flex-direction（设置主轴方向，默认是水平方向row，column设置为垂直方向，可以是反向的）；flex-wrap（设置换行情况，默认是不换行的nowrap，wrap设置新元素下一行，wrap-reverse设置新元素在当前行，需要注意的是，wrap-reverse的第一条主轴线依旧是原来的那条，也就是第一条主轴线会出现在下方）；justify-content（设置盒子在主轴方向上的对齐方式，这个属性优点多，但是一般是center|left|right|space-between|space-around）；align-items（设置侧轴方向上的对齐方式，flex-start设置起点对齐，flex-end设置终点对齐，center设置中间对齐，strech是默认值，如果子元素不设置高度，默认会占满整个容器的高度）；align-content（当具有多个主轴线的时候，设置这些轴线的对齐方式，也就是说当使用了换行之后形成了多条平行的主轴线，可以设置这些主轴线的对齐方式，flex-start|flex-end|center|space-between|space-around|stretch是默认值，会占满整个交叉轴，需要注意的是，当align-content的属性值不是stretch的时候，需要为子元素设置高度，因为某个轴线上子元素的高度会和该轴线上最高的子元素保持一致，如果没有高度，会直接消失）；以上的属性，除了flex以外都是应该设置在父元素上的，并且flex布局是标准流布局"
	},
	"__v": 0
}, {
	"_id": "5e7ceaf9a546f70e24512f59",
	"cr": "4.17",
	"col": 4,
	"row": 17,
	"keyword": "h5c3",
	"msg": {
		"title": "flex-grow",
		"content": "在flex布局中，子元素也具有一些样式属性，来改变其布局；order（用来设置子元素的排列书序，接收一个整数，默认值为0，可以是一个负数，遵循后来者在后的原则），flex-grow（设置项目的放大比率，放大的实现是占用主轴上的剩余空间，通过实数来实现剩余空间的分配，也就是说分配主轴上的空间，类似于份数）"
	},
	"__v": 0
}, {
	"_id": "5e7cee03951e81308ca67fbe",
	"cr": "4.18",
	"col": 4,
	"row": 18,
	"keyword": "h5c3",
	"msg": {
		"title": "flex-shrink",
		"content": "设置子元素的缩小比率，接受一个非负整数，这个属性是在当主轴上的空间不足的时候，子元素会按照比率缩放，默认为1的情况下就是所有元素都是等比缩放，如果某个元素设置了0，则这个子元素不会发生改变；缩小的计算公式是，默认为1的缩放50px，设置为2的就缩放(50x2)px；存在这样一种情况，如果所有子元素缩放都是0，子元素会突破父容器"
	},
	"__v": 0
}, {
	"_id": "5e7cef0b951e81308ca67fbf",
	"cr": "4.19",
	"col": 4,
	"row": 19,
	"keyword": "h5c3",
	"msg": {
		"title": "flex-basis",
		"content": "这个属性定义了在分配多余空间之前，子元素占据的主轴空间，但是如果主轴上的剩余空间不足，这个项目也会缩小，它接受auto或者一个具体的px值，"
	},
	"__v": 0
}, {
	"_id": "5e7cef61951e81308ca67fc0",
	"cr": "4.20",
	"col": 4,
	"row": 20,
	"keyword": "h5c3",
	"msg": {
		"title": "flex",
		"content": "flex属性是flex-grow，flex-shrink和flex-basis的简写，其中flex-grow属性是必须的，用来规定子元素占用主轴的份数"
	},
	"__v": 0
}, {
	"_id": "5e7cf000951e81308ca67fc1",
	"cr": "4.21",
	"col": 4,
	"row": 21,
	"keyword": "h5c3",
	"msg": {
		"title": "align-self",
		"content": "设置单个子元素的对齐方式，auto|flex-start|flex-end|center|baseline|stretch;"
	},
	"__v": 0
}, {
	"_id": "5e7cf088951e81308ca67fc2",
	"cr": "4.22",
	"col": 4,
	"row": 22,
	"keyword": "h5c3",
	"msg": {
		"title": "text-shadow",
		"content": "设置文字的阴影，用来实现艺术字效果等，复合模式text-shadow:h-shadow（水平阴影位置）|v-shadow（垂直阴影位置）|blur（模糊距离）|color（阴影颜色），其中前两个属性是必须的"
	},
	"__v": 0
}, {
	"_id": "5e7cf2fb951e81308ca67fc3",
	"cr": "4.23",
	"col": 4,
	"row": 23,
	"keyword": "h5c3",
	"msg": {
		"title": "BFC",
		"content": "Black formatting context是块级格式上下文，一旦一个元素创建为了一个BFC，它会将其内部所有的元素进行打包，这样这个元素是完全独立的，不会和外部产生相互影响，所以1、经常用来清除浮动，2、解决外边距合并问题，3、因为BFC元素不会和别的元素产生交集，当一个文档流和浮动元素相邻的时候，文档流会自动环绕浮动的元素，但是如果让文档流成为一个BFC元素，那么浮动元素和BFC之间就不会产生相互的影响，这样就可以让文档流和浮动元素并列显示，不过这个经常被用来制作两栏自适应的标签"
	},
	"__v": 0
}, {
	"_id": "5e7cf3ce951e81308ca67fc4",
	"cr": "4.24",
	"col": 4,
	"row": 24,
	"keyword": "h5c3",
	"msg": {
		"title": "background-size",
		"content": "用来设置背景图片的尺寸，默认值是auto（图片本身的尺寸），80px|80px（可以手动设置宽和高），80%（相对于父元素的百分比），cover（保持宽高比例，覆盖住整个父元素），contain（保持宽高比例，然后填满宽或高中较小的一个）"
	},
	"__v": 0
}, {
	"_id": "5e7cf49b951e81308ca67fc5",
	"cr": "4.25",
	"col": 4,
	"row": 25,
	"keyword": "h5c3",
	"msg": {
		"title": "其他的一些点",
		"content": "background:linear-gradient（设置颜色渐变），此外，元素可以设置多背景，每组属性通过【,】来隔开，在使用多背景的情况下，单独的颜色背景应该写在最后；浏览器前缀：-webkit-（chrome,Safari,Android），-moz-（Firefox），-o-（Opera），-ms-（Internet Explore,Edge），-khtml-（Konqueror）"
	},
	"__v": 0
}, {
	"_id": "5e7de5892f844a1454b71d41",
	"cr": "5.1",
	"col": 5,
	"row": 1,
	"keyword": "JavaScript",
	"msg": {
		"title": "JavaScript",
		"content": "JS一般认为由三个部分组成：ECMAScript标准、DOM、BOM"
	},
	"__v": 0
}, {
	"_id": "5e7de80e2f844a1454b71d42",
	"cr": "5.2",
	"col": 5,
	"row": 2,
	"keyword": "JavaScript",
	"msg": {
		"title": "JS的数据类型",
		"content": "number（数字类型，包含小数和整数），string（字符串类型），boolean（布尔类型），undefined（未定义类型），null（空值类型），object（对象类型）；类型的转换的方法，parseInt()（转整数），parseFloat()（转小数），Number()（转数字，这个方法是严格的类型转换，如果传入的参数是NaN，在不会发生转换），String()（转换为字符串），.toString()（转换为字符串），Boolean()（转布尔类型）；对于NaN，当一个数字和一个非数字数据计算的时候，结果会返回NaN，使用isNaN()方法来判断，具有这种特性的数据不会被Number()方法转换，而parseInt()方法对【123xc】这种类型的数据会转换为整数【123】，并且parseInt()方法可以转化为8进制或者16进制；可以使用typeof()方法可以获取参数的数据类型，变量|instanceof|数据类型会返回true或false，也可以用来判断数据的数据类型"
	},
	"__v": 0
}, {
	"_id": "5e7de8e62f844a1454b71d43",
	"cr": "5.3",
	"col": 5,
	"row": 3,
	"keyword": "JavaScript",
	"msg": {
		"title": "JS运算符",
		"content": "除了常用的算数运算符，符合运算符，赋值运算符，三元运算符，关系运算符以外，JS的逻辑运算符是&&（短路与），||（短路或），！（逻辑非）"
	},
	"__v": 0
}, {
	"_id": "5e7dec082f844a1454b71d44",
	"cr": "5.4",
	"col": 5,
	"row": 4,
	"keyword": "JavaScript",
	"msg": {
		"title": "JS的流程控制",
		"content": "默认是顺序结构，存在分支结构（switch-case，if-else），循环结构（while，do-while，for）；循环语句总是在也页面加载完成的时候就执行完毕的；break关键字可以跳出所在的循环，continue关键字会跳过当前循环去执行下一次的循环，return关键字会停止代码块剩余代码的执行"
	},
	"__v": 0
}, {
	"_id": "5e7ded6e2f844a1454b71d45",
	"cr": "5.5",
	"col": 5,
	"row": 5,
	"keyword": "JavaScript",
	"msg": {
		"title": "Array",
		"content": "数组是用来存储一组有序数据的集合，其中的数据类型可以不一致，这里的有序指的是数组中的每个元素都是具有索引值的；数组的声明方式1、通过new|Array()构造方法创建数组实例，2、字面值方式声明数组（声明的同时初始化）；数组的遍历通常是使用for循环来实现，也可以通过数组的实例方法foreach()来实现遍历操作"
	},
	"__v": 0
}, {
	"_id": "5e7dee982f844a1454b71d46",
	"cr": "5.6",
	"col": 5,
	"row": 6,
	"keyword": "JavaScript",
	"msg": {
		"title": "函数声明",
		"content": "函数声明的方式1、函数式声明（function|test(){}），2、表达式声明（var|test=function(){}），3、构造器声明（var|test=new|Function()）；因为函数也是一个对象（数据类型为Function），所以可以通过console.log()方法输出函数的具体结构；拓展，arguments是每个实例方法默认具有的属性，通过这个属性，可以接受函数调用时的参数，这个arguments本质上是一个伪数组，所以可以通过索引来访问具体的参数"
	},
	"__v": 0
}, {
	"_id": "5e7defe02f844a1454b71d47",
	"cr": "5.7",
	"col": 5,
	"row": 7,
	"keyword": "JavaScript",
	"msg": {
		"title": "作用域",
		"content": "分为全局作用域和局部作用域，局部作用域是闭包的基础；作用域链指的是，函数内部使用变量的时候对作用域的检测顺序，函数会首先在自己的定义域内寻找变量，没有的情况下会去外侧作用域寻找变量，直到找到为止，或者在最外侧定义域中没找到变量后报错，闭包的作用就是为了延长作用域链，"
	},
	"__v": 0
}, {
	"_id": "5e7df28d2f844a1454b71d48",
	"cr": "5.8",
	"col": 5,
	"row": 8,
	"keyword": "JavaScript",
	"msg": {
		"title": "变量",
		"content": "在JS中，分为全局变量和局部变量，全局变量是生命在全局作用域内的，也就是最外侧的代码块中，而局部变量是定义在函数中的变量，此外，还存在隐式全局变量，它是在局部作用域内声明的变量，但是它不使用var等关键字来声明，并且它能在局部作用域外被正常访问到； 在JS中，变量以及函数的声明都会被提前到所在作用域的最上方，这是预解析完成的工作，并且多个script标签中的预解析是分段的，相互之间没有影响"
	},
	"__v": 0
}, {
	"_id": "5e7df6b72f844a1454b71d49",
	"cr": "5.9",
	"col": 5,
	"row": 9,
	"keyword": "JavaScript",
	"msg": {
		"title": "对象的创建",
		"content": "由属性和方法构成的一个集合；创建对象的方法1、系统构造函数Object创建（var|obj=new|Object()），2、自定义构造函数（var|obj=new|自定义构造函数()），3、字面值方式创建对象（var|obj={}）;new关键字创建对象的过程1、开辟内存空间，用于存储新对象，2、把this设置为当前对象（所以在构造方法中使用this指代当前实例对象），3、设置属性和方法，4、返回创建的当前对象；访问对象的属性可以使用点语法，也可以使用键值对的方式实现（中括号），不过，当时用一个变量接收键来实现属性的访问的时候，只能使用中括号；可以使用forkey循环来实现对象的遍历（for(var|key|in|Object){console.log(Object[key])}）"
	},
	"__v": 0
}, {
	"_id": "5e7dfa0b2f844a1454b71d4a",
	"cr": "5.10",
	"col": 5,
	"row": 10,
	"keyword": "JavaScript",
	"msg": {
		"title": "数据的传递",
		"content": "基本数据类型（number，boolean等值类型）在数据的传递过程中传递的是值；复杂数据类型（string，array，Object等引用数据类型都是通过构造函数来创建对象的，对象是存储在堆内存中的，每个对象都具有一个地址【引用】，这个地址是在栈内存中的）在数据传递的过程中传递的是地址"
	},
	"__v": 0
}, {
	"_id": "5e7dfc0a2f844a1454b71d4b",
	"cr": "5.11",
	"col": 5,
	"row": 11,
	"keyword": "JavaScript",
	"msg": {
		"title": "对象的分类",
		"content": "JS中存在着一系列的内置对象，这些内置对象具有一系列的方法和常量；此外还存在着自定义对象，通过自定义的构造函数来创建对象，BOM对象和DOM对象"
	},
	"__v": 0
}, {
	"_id": "5e7dfdac2f844a1454b71d4c",
	"cr": "5.12",
	"col": 5,
	"row": 12,
	"keyword": "JavaScript",
	"msg": {
		"title": "Math对象",
		"content": "Math对象是JS中用来进行数学操作的一个对象，但是这个对象并没有构造函数，它所有的方法都是静态的方法；ceil()（向上取整）；floor()（向下取整）；abs()（取绝对值）；random()（生成0-1之间的随机数）；max()（获取一系列数字中的最大值）；min()（获取最小值）；sqrt()（求平方根）pow(x,y)（求x的y次幂）"
	},
	"__v": 0
}, {
	"_id": "5e7dff702f844a1454b71d4d",
	"cr": "5.13",
	"col": 5,
	"row": 13,
	"keyword": "JavaScript",
	"msg": {
		"title": "Date对象",
		"content": "（先注意下，不要再写成data了）日期对象，这个对象是有构造函数的，所以调用的大多数是实例方法；new|Date()（根据当前时间创建时间对象）.valueOf()（获取时间对象的毫秒数，因为Date类型的数据无法直接参与数学运算，所以需要根据毫秒数来进行运算）；.getMonth()（获取月份，从0开始）；getDay()（获取星期日期，从0开始）；.DateString()（英文格式显示时间）；toLocaleDateString()（数字格式）；.toTimeString()（带有具体时分秒的数字格式）"
	},
	"__v": 0
}, {
	"_id": "5e7e074b2f844a1454b71d4e",
	"cr": "5.14",
	"col": 5,
	"row": 14,
	"keyword": "JavaScript",
	"msg": {
		"title": "String对象",
		"content": "String是一个构造函数，它是一个引用数据类型，因此字符串是没有办法直接修改值的，而是重新创建对象并赋值地址；字符串可以看做是一个字符数组，所以字符串对象可以使用一些数组的方法（索引，length，-，+）；方法：.length（字符串的长度），.charAt()（返回对应索引位置的字符），String.fromCharCode(int)（这是一个静态方法，传入一个整数，返回对应的ASCII值），.concat(字符串...)（字符串拼接，同样的，因为字符串是一个对象，所以不能改变原有的值，该方法会形成一个新的字符串对象，然后把这个新对象的地址赋值给其它变量），.indexOf(str,num)（返回字符串str第一次出现的索引位置，如果没有则会返回-1，num参数设定开始查询的索引位置），.lastIndexOf(str,num)（字符串str最后出现的索引位置，num参数设置检索结束的位置），.replace(str,newStr/匿名函数)（将str替换为newStr），.slice(sIndex,eIndex)（按照索引进行字符串的截取，这是数组的方法，但是字符串也能使用），.split(str,num)（依据str的符号来分割字符串，num参数设置保留的字符串的个数，这个方法会返回一个数组），.substr(sIndex,length)（从sIndex开始，截取length长度的字符），.substring(sIndex,eIndex)（截取字符串），.toLocaleLowerCase()（转小写，这个方法是为了针对特定地区的编码格式而设置的方法），.toLowerCase()（转小写），.toUpperCase()（转大写），.toUpperCase()（转大写），.trim()（清除两端空格）；需要注意的是，slice()，substring()，substr()三个方法是可以传入负数的，其中slice()方法会将负数和数组长度相加作为实际的参数，也就是获取后几位的效果，而substring()方法会把所有负数转化为0，substr()方法会把sIndex转化为后几位的方式，而把length的负数转化为0,；需要重点提醒的是，虽然JS是弱类型的语言，但是其实例方法的调用是会检测数据类型的，所以一定要确定数据类型之后再选用方法"
	},
	"__v": 0
}, {
	"_id": "5e7e103f2f844a1454b71d4f",
	"cr": "5.15",
	"col": 5,
	"row": 15,
	"keyword": "JavaScript",
	"msg": {
		"title": "Array对象",
		"content": "Array也是一个构造函数，通过调用静态方法Array.isArray(变量)来检测一个变量是不是数组；实例方法：.concat(arr...)（合并数组），.push(值)（把数值追加到数组的最后，返回新数组的长度，使用这种方法不需要重新接受数组），.pop()（删除数组中最后一个元素，返回被删除的元素的值），.shift()（删除数组中的第一个元素），.unshift(值)（在数组中的第一个元素前面插入新的值，返回新数组的长度），.indexOf(ele)（返回元素ele在数组中的索引值，没有时返回-1），.join(str)（使用str作为间隔符号，把数组转换为一个字符串，返回一个字符串），.reverse()（翻转整个数组），.slice(sIndex,eIndex)（截取sIndex和eIndex之间的元素组成新的数组，不包括结束索引对应的元素值，这个方法不需要让数组重新赋值，但是当该方法被字符串使用的时候，字符串需要通过重新赋值来实现字符串的截取），.splice(sIndex,length,[ele])（从sIndex开始删除length个元素，并且使用ele来代替被删除的元素），.every(Func)（用于检测数组中的元素是否符合Func中的条件，方法返回值是布尔类型的值，如果全部符合就是true，否则为false），.filter(Func)（返回数组中符合Func函数的所有元素，组成一个新的数组），.forEach(Func)（遍历数组中的元素，执行Func函数中的代码，这个方法不需要返回值），.map(Func)（返回一个新数组，数组中的每个元素都调用了Func）；以上方法中，操作添加和删除数组以及翻转数组的方法（push，pop，shift，unshift，reverse，slice，splice）都是会直接改变数组对象在堆内存中的数据，所以不需要通过重新赋值来实现数组数据的更新；而一系列需要传入函数来实现的方法（every，filter，foreach，map）可以通过传入匿名函数来实现，这个函数具有三个参数，依次是currentValue、currentIndex、currentArr，这些参数可以通过arguments来查看，并且通过这些方法获取新的数组（filter和map）的情况下需要重新接受这个数组；最后，.sort(compareFunc)方法可以让数组按照compareFunc进行排序，这个方法不需要重新接收数组，关于这个compareFunc，它的实现逻辑是1、当没有参数这个比较函数的时候，将按照字符编码的顺序来进行排序，2、需要自定义排序的情况下，传入比较函数，比较函数会比较两个值，然后返回一个说明两个值的相对顺序的数字（说白了就是，传入a，b两个参数，a<b时return-1；a=b时return0；a>b时return1）"
	},
	"__v": 0
}, {
	"_id": "5e7e27a2d44e8d170098bed2",
	"cr": "5.16",
	"col": 5,
	"row": 16,
	"keyword": "JavaScript",
	"msg": {
		"title": "DOM简介",
		"content": "DocumentObjectModel文档流对象，它是主要作用是用来操作页面中的元素（元素也可以看做一种对象），整个文档流可以看做一个DOM树，而document就是这个DOM树的根元素；原生的JS就可以操作DOM，例如获取元素对象，更改属性，为元素添加事件等；元素本质上就是各种标签，而在DOM中除了标签还存在着节点（node）这一概念，节点包含了文档流中的所有内容，除了元素以外，还包括了属性和文本；注意，document是文档流中的顶级对象，因此可以给document绑定事件"
	},
	"__v": 0
}, {
	"_id": "5e7e2a4fd44e8d170098bed3",
	"cr": "5.17",
	"col": 5,
	"keyword": "JavaScript",
	"msg": {
		"title": "DOM基本操作",
		"content": "获取元素的方法：document.getElementById('id的属性值')（根据id获取元素对象）；document.getElementsByTagName('标签名称')（根据标签名称获取元素对象数组）；document.getElementsByClassName('class属性的值')（根据class属性来获取对象）；document.querySelector('css选择器')（根据选择器来获取匹配的第一个元素对象）；document.querySelectorAll('css选择器')（根据选择器获取所有匹配的对象）；修改基本属性：可以修改的基本属性（src|title|alt|href|id），可以修改的表单标签的属性（name|value|type|checked|selected|disabled|readonly）；操作元素的样式：对象.style.属性=值，或者通过让对象获取class类样式来实现元素样式的更改对象.className=值（需要注意的是，使用这种方法，需要用空格隔开多个类样式名称）；添加事件的操作：对象.onclick=function(){}；注意，在每个DOM对象中，this关键字指代的都是这个对象本身，但是在匿名函数中需要注意this的指向"
	},
	"__v": 0,
	"row": 17
}, {
	"_id": "5e7e2b28d44e8d170098bed4",
	"cr": "5.18",
	"col": 5,
	"row": 18,
	"keyword": "JavaScript",
	"msg": {
		"title": "麻烦的兼容问题1",
		"content": "innerText和textContent；innerText被所有浏览器支持，它是IE的标准，而textContent是火狐浏览器的标志，IE8并不支持它，这两者都是用来设置内容的，如果想要让浏览器解读标签，需要使用innerHTML"
	},
	"__v": 0
}, {
	"_id": "5e7e2bd0d44e8d170098bed5",
	"cr": "5.19",
	"col": 5,
	"row": 19,
	"keyword": "JavaScript",
	"msg": {
		"title": "DOM自定义属性",
		"content": "自定义属性经常被用来存储一定的数据，方便作为操作是的标志或者参数；对象.getAttribute(‘属性’)（获取自定义属性），对象.setAttribute('属性','值')（设置自定义属性的值），对象.removeAttribute('属性')（删除自定义属性）"
	},
	"__v": 0
}, {
	"_id": "5e7e2c30d44e8d170098bed6",
	"cr": "5.20",
	"col": 5,
	"row": 20,
	"keyword": "JavaScript",
	"msg": {
		"title": "node简介",
		"content": "节点是文档流中的所有内容的集合，它包含了标签，属性以及文本；文本包括：空格、换行、文字等；节点的作用是为了更好的获取元素（标签）；节点的属性（nodeType）：标签节点（数字代表为1），属性节点（2），文本节点（3）；节点的名字（nodeName）：标签会显示为标签的名字（大写），属性会显示为属性的名字（小写），文本会显示#text；节点的值（nodeValue）：标签（null），属性（属性值），文本（文本内容）"
	},
	"__v": 0
}, {
	"_id": "5e7e2f42d44e8d170098bed7",
	"cr": "5.21",
	"col": 5,
	"row": 21,
	"keyword": "JavaScript",
	"msg": {
		"title": "node的获取",
		"content": "节点的获取可以直接通过对象的属性来获取；对象.parentNode（获取当前节点的父节点），对象.parentElement（获取父元素），对象.childNode（获取子节点），对象.children（获取子元素）；还有一些其他的获取节点的方法，但是兼容性堪忧：对象.firstChild（获取当前节点的第一个子级节点），对象.firstElementChild（获取当前节点的第一个子级元素），对象.lastChild（获取当前节点的最后一个子级节点），对象.lastElementChild（获取当前节点的最后一个子级元素），对象.previousSibling（获取当前节点的前一个兄弟节点），对象.prebiousElementSibling（获取当前节点的前一个兄弟元素），对象.nextSibling（获取当前节点的后一个兄弟节点），对象.newElementSibling（获取当前节点的后一个兄弟元素）；需要注意的是，所有获取节点的方式都是通过对象的属性获取的，它们并不是方法；IE8中使用获取节点的代码会直接获取相应的元素，而获取元素的代码是不被支持的"
	},
	"__v": 0
}, {
	"_id": "5e7e314bd44e8d170098bed8",
	"cr": "5.22",
	"col": 5,
	"row": 22,
	"keyword": "JavaScript",
	"msg": {
		"title": "元素的创建",
		"content": "三种创建方式：1、document.write('标签代码以及内容')（这个方法很暴力，会直接在文档流中创建新的元素，覆盖原有的），2、父元素.innerHTML='标签代码以及内容'（这个方法同样是暴力的，创建新HTML内容代替原有的），3、document.createElement('标签名称')（这会创建一个纯粹的标签，内容需要手动添加，然后需要添加到某个元素中器；父级元素.appendChild(子级元素对象)（在末尾添加新元素），或者父级元素.insertBefore(新的子级元素，参照的对象)（在参照对象的前面添加新元素），相应的，也有移除元素的操作，父级元素.removeChild(子元素对象)）"
	},
	"__v": 0
}, {
	"_id": "5e7e328fd44e8d170098bed9",
	"cr": "5.23",
	"col": 5,
	"row": 23,
	"keyword": "JavaScript",
	"msg": {
		"title": "事件绑定",
		"content": "三种方式：1、对象.onclick=Func（如果注册了多个相同类型的事件，后来者居上），2、对象.addEventListener('click',Func,false)（这个一个IE8不支持的事件绑定方式，其中第三个参数决定着事件的执行阶段，false代表着冒泡阶段，true代表着捕获阶段），3、对象.attachEvent('onclick',Func)（这是IE8专用的方式）；相应的也有三种事件解绑的方式：1、对象.onclick = null，2、对象.removeEventListener('click',事件处理函数,false)，3、对象.detachEvent('onclick',事件处理函数)；因为IE8和其他浏览器的事件绑定方式不同，所以会需要进行兼容"
	},
	"__v": 0
}, {
	"_id": "5e7e3413d44e8d170098beda",
	"cr": "5.24",
	"col": 5,
	"row": 24,
	"keyword": "JavaScript",
	"msg": {
		"title": "事件的三个阶段",
		"content": "每个事件都会有三个阶段：1、捕获阶段，这个阶段是从外向内发生的（即是说父元素包裹子元素，会先捕获父元素的同类型的事件），2、目标阶段（不甚了解），3、冒泡阶段，这个阶段是从内向外发生的；通过事件参数对象可以返回事件所处的状态（e.eventPhase，事件参数对象存储着当前事件的信息，也是需要进行兼容的）；事件冒泡会导致内层同类型的事件触发，所以应该尽量避免：1、e.stopPropagation()（这个IE8不能使用），2、在IE8中使用window.event.cancelBubble=true"
	},
	"__v": 0
}, {
	"_id": "5e7e3570d44e8d170098bedb",
	"cr": "5.25",
	"col": 5,
	"row": 25,
	"keyword": "JavaScript",
	"msg": {
		"title": "BOM",
		"content": "BrowserObjectModel，浏览器对象模型，它是用来操作浏览器的一些功能的（例如历史记录history，地址栏信息location，系统和浏览器信息navigator）；window是BOM中的顶级对象，最为重要的就是定时器是属于window的方法（window在大多数时候都是可以省略的）"
	},
	"__v": 0
}, {
	"_id": "5e7e3727d44e8d170098bedc",
	"cr": "5.26",
	"col": 5,
	"row": 26,
	"keyword": "JavaScript",
	"msg": {
		"title": "location对象",
		"content": "作为BOM的属性，它主要包含了地址栏的信息以及操作，.hash属性是一个字符串，它是url的锚点部分（具体显示为从#开始的部分），.href属性是当前浏览器的url地址（字符串），.host属性是服务器的名称以及端口号（字符串），.pathname属性是文件的相对路径（字符串），.protocol是传输协议（字符串），.search是搜索的内容（字符串，？之后的部分）"
	},
	"__v": 0
}, {
	"_id": "5e7e37d8d44e8d170098bedd",
	"cr": "5.27",
	"col": 5,
	"row": 27,
	"keyword": "JavaScript",
	"msg": {
		"title": "定时器",
		"content": "定时器是属于window的方法，存在两种类型：1、一次性定时器setTimeout(fn,speed)，使用clearTimeout(timeId)来清除定时器；2、循环定时器setInterval(fn,speen)，使用clearInterval(timeId)来清除定时器，定时器一定要及时的清除"
	},
	"__v": 0
}, {
	"_id": "5e7e38fdd44e8d170098bede",
	"cr": "5.28",
	"col": 5,
	"keyword": "JavaScript",
	"msg": {
		"title": "JS的三大系列",
		"content": "分别是offset系列（DOM属性，用来获取元素的高宽等属性），scroll系列（DOM属性，用来获取元素发生卷曲时，卷曲的距离），client系列（DOM属性，获取页面中的宽高，坐标等属性）"
	},
	"__v": 0,
	"row": 28
}, {
	"_id": "5e7e3ad4d44e8d170098bedf",
	"cr": "5.29",
	"col": 5,
	"row": 29,
	"keyword": "JavaScript",
	"msg": {
		"title": "offset系列",
		"content": "1、offsetWidth（获取元素的宽度，类似于content-box模式下的宽度），2、offsetHeight（获取高度），3、offsetParent（获取具有定位属性的上一级父级元素，如果都没有定位，返回body），4、offsetLeft（获取元素距离父元素左侧的实际距离，并不是单纯的获取左偏移的数值，本质上是margin-left+边偏移left），5、offsetTop（获取元素距离页面上侧的实际距离）"
	},
	"__v": 0
}, {
	"_id": "5e7e3b38d44e8d170098bee0",
	"cr": "5.30",
	"col": 5,
	"row": 30,
	"keyword": "JavaScript",
	"msg": {
		"title": "scroll系列",
		"content": "1、scrollWidth（获取元素内容的宽度，这是一个只读属性，这个宽度是内容驱动的，即是设置了移除隐藏也不会改变内容的真是宽度，但是，当元素中内有内容的时候，这个属性会获得元素的宽度，这个宽度的计算公式是元素的设置宽度+左右内边距，于边框以及外边距无关，也就是说获得的还是元素的内容的大小，只不过当元素没有其他内容的时候，整个元素就是内容），2、scrollHeight（获取盒子的高度，这是因为盒子一般是比内容高的，当内容高度高于盒子的时候获取的就是内容的高度，也就是说其最小值就是内容的高度，一般情况下是获取盒子的盖度），3、scrollLeft（onscroll事件发生时，元素向左卷曲的距离，可以读取或设置元素滚动条到元素左边的距离，在现今浏览器更新后，使用document.documentElement.scrollLeft来获取左侧卷曲的程度，或者在IE9以上使用BOM属性window.pageXOffset，这个属性和滚动轴息息相关，注意window.scrollX也有类似的效果）4、scrollTop（onscroll事件出发时，向上卷曲的距离）；注意，产生大量获取卷曲距离的属性的原因在于，不同浏览器对于文档的解读是不同的，当设置了文档头，chrome和safari浏览器内核会把document.body.scrollTop解析为0,所以要使用document.documentElement.scrollLeft，而另外两个属性是属于BOM的，会忽略文档头"
	},
	"__v": 0
}, {
	"_id": "5e7e46aad44e8d170098bee1",
	"cr": "5.31",
	"col": 5,
	"row": 31,
	"keyword": "JavaScript",
	"msg": {
		"title": "client系列",
		"content": "1、clientWidth（获取可视区域的宽度，这个宽度就是盒子宽度+左右内边距，这个和offsetWidth获取内容宽度很类似，不过这个属性是盒模型驱动的，同样的overflow设置溢出隐藏并不能影响这个属性），2、clientHeight（获取元素可视区域的高度），3、clientTop（获取上边框的宽度，本质上是上部可视区域的高度，盒模型的上方就只有border和margin，margin是不可视的，所以就是获取上边框的宽度），4、clientLeft（获取左边框的宽度），5、clientX（获取鼠标在当前可视区域内的横坐标，它是事件对象e中的一个属性，当存在滚动条的时候，这个坐标就不是鼠标在浏览器中的横坐标了；使用e.pageX属性可以获取相对于整个页面的横坐标，但是这个属性是属于浏览器的，因此可以存在一定的误差，在实际操作过程中，使用向左卷曲的距离+当前页面的鼠标横坐标来获得相对于整个页面的横坐标），6、pageY（获取当前可视区域内的鼠标纵坐标）"
	},
	"__v": 0
}, {
	"_id": "5e7f71197f3ea01860e25005",
	"cr": "6.1",
	"col": 6,
	"row": 1,
	"keyword": "JS对象化",
	"msg": {
		"title": "JS对象化",
		"content": "随着技术的不断发展，JS不只限于满足浏览器的各种脚本操作，它也逐步成为连接前端和后端的一种语言，具有特征的就是node.js实现的服务端操作等，在node.js的基础上，发展出了各种不同的贯穿前端和后端的JS框架，而这一切的基础就是JS语言中也能够使用对象化这一概念，这是JS实现服务端编程的基础。JS的对象化的基础是原型，通过原型可以实现类似于Java语言的继承，回调函数等操作"
	},
	"__v": 0
}, {
	"_id": "5e7f7e937f3ea01860e25006",
	"cr": "6.2",
	"col": 6,
	"row": 2,
	"keyword": "JS对象化",
	"msg": {
		"title": "原型基础",
		"content": "原型是JS实现对象化，模块化编程的基础，在JS语言中，原型是每个构造函数具有的属性prototype，而每个实例化的对象也具有一个相似的属性，它是_proto_，这个属性的指向就是构造函数中的prototype属性，所以处在构造函数prototype属性中的方法等内容是可以被对象直接调用的（这就很类似于Java中构造函数中的实例方法和实例属性，在main方法中可以通过引用直接调用这些常量属性和方法）；从上面这段话可以看出，prototype属性的值也是一个对象，这个对象存储着构造函数的公有属性和方法（Java中class中的实例方法和常量属性），而这么做的目的就是实现数据共享，节省内存空间（可以不用每声明一个对象就实例化一份数据，而是让实例化对象通过继承构造函数的实例方法和常量属性来节省内存空间，具体的表现为_proto_指向了prototype，prototype中存储了实例方法和常量属性）"
	},
	"__v": 0
}, {
	"_id": "5e7f84007f3ea01860e25007",
	"cr": "6.3",
	"col": 6,
	"row": 3,
	"keyword": "JS对象化",
	"msg": {
		"title": "原型链",
		"content": "这是一种多继承的体现，即是说只要是一个实例化对象，它就会具有_proto_属性，这个属性会指向该实例化对象的构造函数的prototype属性，而因为prototype属性本身是一个对象，所以它也具有_proto_属性，而这个_proto_也会指向一个构造函数的prototype属性，就这样会一直追溯下去，直到某个prototype对象的_proto_的指向是null，而null是空对象，它是没有原型的（JS定义的无原型），原型链就会停止了，而这个null通常就是Object的prototype属性的_proto_属性（在最新的JS规则中，Object的prototype属性中不再具有_proto_属性），这是因为JS中的对象几乎都是位于原型链顶端的Object的实例；"
	},
	"__v": 0
}, {
	"_id": "5e7f89e17f3ea01860e25008",
	"cr": "6.4",
	"col": 6,
	"row": 4,
	"keyword": "JS对象化",
	"msg": {
		"title": "原型中的构造函数",
		"content": "原型链的形成是通过实例对象的_proto_指向构造函数的prototype属性，这个本质上是实例对象的_proto_属性中是继承的常量属性以及方法，剩下有一个属性是constructor，它就是构造器，在这个构造器中存在有一个prototype属性，实例对象_proto_属性指向的就是构造器中的这个prototype属性；此外，因为_proto_属性本质上是一个对象，所以它也会具有一个_proto_属性，这个属性指向了Object原型链的顶端，而Object.prototype是没有_proto_属性的（在之前是存在过这个属性的，但是现在废弃了），所以原型链到此就停止了；还有就是，constructor构造器一般是函数的形式出现的，而函数也是一种对象，这就导致了在constructor内也存在着_proto_属性，它指向了Function构造函数的prototype属性，同样的，这个Function构造函数是Object的实例，所以它的constructor中也存在着_proto_属性，并且指向了Object的prototype属性；"
	},
	"__v": 0
}, {
	"_id": "5e7f8ec07f3ea01860e25009",
	"cr": "6.5",
	"col": 6,
	"row": 5,
	"keyword": "JS对象化",
	"msg": {
		"title": "原型的指向",
		"content": "通过原型可以很容是的实现继承，所以自定义的构造函数通过修改其原型对象（prototype）可以实现实例方法和常量属性的创建，而这种方法创建的原型对象是不存在构造器的，因此需要手动添加构造器，让原型对象和构造器产生关联；原型的指向是可以修改的，修改的方法就是直接修改构造函数的prototype属性的值，而这么操作的方法，会使得实例对象的_proto_属性指向新的值，而不再是一个构造器中的prototype属性，而这个值往往是一个其他的实例对象，这样_proto_属性指向是一个实例对象，而这个对象会获取其构造函数的实例方法，这样一开始的实例对象就能通过这个对象获得其构造函数中的方法，此外，这个新的指向对象本身也具有_proto_属性，它的指向是自身构造函数中的prototype属性，而当自定义构造函数没有声明原型对象（prototype）于构造函数之间的关系的时候，是不会存在构造器（constructor）属性的；最为重要的是，原型的指向可以更改是实现继承的基础"
	},
	"__v": 0
}, {
	"_id": "5e7f97c97f3ea01860e2500a",
	"cr": "6.6",
	"col": 6,
	"row": 6,
	"keyword": "JS对象化",
	"msg": {
		"title": "JS继承的准备",
		"content": "在JS中实现继承的基础是原型对象（prototype）的指向是可以改变的；但是仅仅这一点是不够的，因为在改变原型对象指向的时候，赋值的是其他构造函数的实例对象，因为是一个实例对象，所以其实例属性是确定的，也就是说该实例对象的实例属性成为了原型对象中的常量属性，通过该原型对象的构造函数创建的新的实例对象的相关属性都是相同的值，可以总结为，通过改变原型对象的指向这一方法可以继承其他构造函数中的方法，但是无法直接继承其他构造函数中的属性（这里的属性指的是实例属性，而不是原型对象中存储的常量属性）；所以，需要通过改变this的指向来实现对其他构造函数中属性的继承，（改变this指向的原理在于，在构造函数中，this指代的是当前的构造函数，这个this属性是局部的，只可以在构造函数的作用域内使用，当在一个构造函数中调用其他函数的实例方法（或者属性）的时候，因为this的指向是当前构造函数，所以无法调用，而如果让其他构造函数中的this指向的是当前的构造函数，那么就能顺利的调用了【this是局部的很重要，因为如果在构造函数中有其他对象调用而来方法，在方法中this的指向会变成调用该对反方的实例对象，而不再是当前的构造函数】），在事件中通常是通过.apply()，.call()方法来实现继承其他构造函数实例属性，具体操作是，在新的构造函数中调用其他构造函数的构造方法（就是Person()这种创建实例对象的方法），然后使用.apply()方法绑定当前构造函数的this；需要注意的是，通过apply()或者call()方法改变老构造函数指向的话，会自动改变老构造函数中所有方法的指向，但是对于实例属性，需要通过apply()或者call()方法按照顺序传入新构造函数中的参数；实例表现：function|Students|(name,sex,age.score){Person.call(this,name,sex,age)|this.score=score}"
	},
	"__v": 0
}, {
	"_id": "5e7f9f377f3ea01860e2500b",
	"cr": "6.7",
	"col": 6,
	"row": 7,
	"keyword": "JS对象化",
	"msg": {
		"title": "改变this指向的三种方式",
		"content": "这三种方法都是Function对象的实例方法；1、apply(this,arr)（改变函数调用时的this指向，既可以是方法调用，也可以是构造函数调用，this就是新的指向，arr是原方法需要传入的参数，必须是以数组的方式传入），2、call(this,args...)（与apply()类似，传参数的方式不同，需要注意的是，this属性是必须的，当不传入实参时默认为null，也就是this指向全局对象【window】），3、bind(this,args...)（这个方法会创建一个新的函数，this参数决定了这个新函数的this指向，而args是在函数被调用的时候，预设置入的一系列参数，需要注意的是，使用bind()方法获取的是一个新的函数，因此需要接收或者直接调用）；通过这些改变this的方式，就能很清晰的明白对于实例属性的继承了：Person()构造方法的调用，其this指向本来是Person构造函数本身，当时当它在其他构造函数中被调用，并且通过apply(this,[])方法改变了this的指向为当前构造函数，并且传入了Person()构造方法创建实例对象时需要的参数，这样就完成了对于Person()中实例属性部分的调用（除了这些实例属性以外，还包括了直接声明在构造函数中的方法）"
	},
	"__v": 0
}, {
	"_id": "5e8070406876211794580572",
	"cr": "6.8",
	"col": 6,
	"row": 8,
	"keyword": "JS对象化",
	"msg": {
		"title": "JS的组合继承",
		"content": "通过修改构造函数中原型独对象（prototype）的指向，以及在构造方法中通过call()等方法改变this的指向来调用其他构造方法，就能完成JS中的组合继承；组合继承的特点就是新的构造函数既能继承其他构造函数的实例属性，也能继承实例方法"
	},
	"__v": 0
}, {
	"_id": "5e80750d6876211794580573",
	"cr": "6.9",
	"col": 6,
	"row": 9,
	"keyword": "JS对象化",
	"msg": {
		"title": "闭包",
		"content": "闭包指的就是能够读取其他函数内部变量的其他函数，在JS中，闭包表现为在某个函数内部的子函数；闭包的作用就是缓存数据，延长作用域链，具体的表现为子函数可以使用外部函数中定义的变量，这样就实现了子函数内部和外部函数的连接，延长了外部函数的作用域链到子函数中"
	},
	"__v": 0
}, {
	"_id": "5e8079f06876211794580574",
	"cr": "6.10",
	"col": 6,
	"row": 10,
	"keyword": "JS对象化",
	"msg": {
		"title": "沙箱",
		"content": "沙箱指的就是一个封闭的环境，无法主动的影响外界，在JS中的表现就是通过自执行函数实现沙箱的封装，需要在外部进行访问的属性和方法，通过window的自定义属性将闭包中的函数暴露给window对象，然后通过window对象来调用所需的属性和方法（window对象一般是可以省略的）；一个常用的例子就是，在沙箱中声明一个构造函数，然后通过window.属性将构造函数暴露给window对象，这样就形成了一个沙箱，或者说形成了一个包，通过引入相关的JS文件，就能通过window.属性来调用构造函数了"
	},
	"__v": 0
}, {
	"_id": "5e8081146876211794580575",
	"cr": "6.11",
	"col": 6,
	"row": 11,
	"keyword": "JS对象化",
	"msg": {
		"title": "数据拷贝",
		"content": "在接口中经常会接受一些数据，而这些数据经常是一个对象，甚至于对象内部的属性指向的也是一个对象，这是就需要通过拷贝来接受数据并赋值给一个接口中的属性，方便来操作这些数据；1、如果直接把对象赋值给接口中的自定义属性，name自定义属性虽然获取了对象中的数据，但是自定义属性和对象的指向是一样的（直接赋值的本质就是把堆内存中的地址传递给了新的自定义属性），当数据是一次性的时候，这可以进行，但是当对象中的数据更改会引起接口中自定义属性中数据的更改，所以需要深拷贝来完成接口中数据的独立化，2、使用assign(target，obj...)方法进行深拷贝，assign()方法是ES6提供的一个方法，它可以完成一级属性的深拷贝（就是对象中的值属性实现深拷贝），而对于第一级一下的属性会进行浅拷贝（就是说对象中的对象属性并不会进行深拷贝，而是传递对象的地址），所以说assign()方法本质上还是一个传递值的拷贝，但是它传递的值是来自于对象中的属性值（可以是具体的值或者是引用地址），所以实现了一定的深拷贝，3、使用JSON对象完成深拷贝（JSON.parse(JSON.stringify(obj))来完成深拷贝，本质是把一个JS值（对象或者数组）转换为JSON字符串，然后使用JSON.parse()方法来解析JSON字符串，返回字符串描述的JS值（对象或者数组））;JSON的特点是，JSON对象每个数据都是键值对，而键永远是被双引号包裹着的，所以JSON对象是无法直接通过.属性的语法来调用相关数据的，所以需要把JSON对象转化为字符串，然后在通过JSON.parse()方法解释为JS值；JSON.stringify()方法获取的字符串中使用转义字符来表示空字符（空格或者换行），而在JSON.parse()方法解析的时候，同样是识别转义字符，对于空格，解析过程中或默认删除，而对于换行，如果不是转义字符，会直接报错，而解析过程中还是默认删除的"
	},
	"__v": 0
}, {
	"_id": "5e808a806876211794580576",
	"cr": "7.1",
	"col": 7,
	"row": 1,
	"keyword": "jQuery",
	"msg": {
		"title": "jQuery",
		"content": "jQuery是一个JS库，它封装了大量的原生JS的方法，并且做了IE和其他浏览器的兼容，让pc端的JS操作变的更加简单；需要注意的是，jq的对象和原生JS的DOM对象是不同的，具体表现为两者的方法是不能混用的，不过两者之间可以像话转换的：$(DOM)--->jq对象，jq对象.get(index)--->DOM；JQ和原生的JS一样需要一个入口函数：$(document).ready(function(){})，或者简写为$(function(){})，本质还是JS的入口函数，只不过是把JS中DOM的顶级对象document转变成了jq对象"
	},
	"__v": 0
}, {
	"_id": "5e80970b92a5df27084f9d97",
	"cr": "7.2",
	"col": 7,
	"row": 2,
	"keyword": "jQuery",
	"msg": {
		"title": "JQ获取对象",
		"content": "JQ做了封装，可以通过css选择器快速的获取都相关的jq对象；除了基础的css选择器以外，还有过滤选择器：:odd（奇数选择器，获得的是一个数组），:even（偶数选择器），:eq(index)（指定元素），:gt(index)（大于下标的元素，返回一个数组），:lt(index)（小于下标的元素，返回一个数组）；此外还有筛选选择器：.children()（获取子代元素jq对象），.find()（获取后代元素jq对象），.parent()（获取父级元素jq对象），.sibilings()（获取当前jq对象的兄弟元素对象），.next()（同级别的下一个对象），.prev()（同级别的前一个对象），.eq(index)（指定下标的对象）；使用index()方法可以获取当前对象在所有兄弟元素中的下标"
	},
	"__v": 0
}, {
	"_id": "5e80a44e92a5df27084f9d98",
	"cr": "7.3",
	"col": 7,
	"row": 3,
	"keyword": "jQuery",
	"msg": {
		"title": "JQ操作样式",
		"content": "1、.css(attribute，value)，给单个样式attribute设置属性为value，2、.css(obj)，可以同时设置多个样式的属性值，另外.css(attribute)方法可以获取attribute的属性值，3、此外，可以通过操作类样式来实现元素的样式操作，.addClass(className)，为对象添加className的类样式，这个方法会直接为对象相应的元素的class属性添加一个新的类样式className，多次添加的className是可以共同存在的（就是说后添加的不会覆盖已有的类样式），此外可以通过removeClass(className)删除指定的类样式，hasClass(className)可以判断对象是否具有目标类样式，toggleClass(className)是在多个类样式之间进行切换（切换的本质是检测当前的class属性值，然后删除这个值，添加其他的值）；除了操作样式以外，JQ也可以操作属性（包括自定义属性）：1、attr(attribute，value)（为单个属性设置值，可以用来新建自定义属性），2、attr(obj)（为多个属性设置值），3、attr(attribute)（用来获取attribute的属性值），4、removeAttribute(attribute)（删除属性，这个方法就是封装了JS的同名方法），5、prop()是一系列类似于attr()方法的操作，但是它经常是被用来操作布尔类型的属性的（disabled，selected，checked）"
	},
	"__v": 0
}, {
	"_id": "5e80ac5c92a5df27084f9d99",
	"cr": "7.4",
	"col": 7,
	"row": 4,
	"keyword": "jQuery",
	"msg": {
		"title": "JQ动画",
		"content": "JQ封装了三组显示隐藏动画，此外还封装而来自定义动画的声明方式；1、三组基本动画：show(speed，fn)和hide()（当不传入参数的时候会直接显示，speed参数可以设定渐变动画的时间，fn参数是一个回调函数，会在动画执行完毕之后调用这个函数）；slideDown(speen,fn)和slideUp()（这组动画具有默认的动画效果，其他的和show()方法类似，此外，存在着slideToggle()方法，它可以完成切换动画）；fadeIn(speed,fn)和fadeOut()（和slideDown类似），2、自定义动画：animate({},duration,timerFunc,callbackFn)（自定义动画通过{}来接收动画改编的样式，duration参数设定动画完成需要的时间，timerFunc参数是设定动画执行过程中使用的动画曲线，最后一个参数是回调函数），3、动画序列：JQ会把动画存储到一个队列中去，每个动画逐次执行，但是通过对象的stop(stopAll,goToEnd)方法可以停止当前正在进行的动画，直接跳到下一个自定义动画，这个方法的两个参数都是布尔类型的，其中stopAll参数规定了是否停止所有的自定义动画（清空动画队列），goToEnd参数规定了是否直接跳到当前动画的最终状态，这个属只会在设定了stopAll后生效"
	},
	"__v": 0
}, {
	"_id": "5e80b16592a5df27084f9d9a",
	"cr": "7.5",
	"col": 7,
	"row": 5,
	"keyword": "jQuery",
	"msg": {
		"title": "JQ操作节点",
		"content": "1、创建节点，JQ操作的节点也是一个jq对象，所以创建的节点需要使用$符号转换为jq对象（如果不是一个jq对象的话，需要保证创建的节点是一个字符串，这个字符串会在添加的时候被解析为jq对象）；2、添加节点，append($obj)方法是让在父元素最后面添加一个子元素（这个方法是封装了appendChild实现的，所以它会直接在父元素的最后添加一个子元素），prepend($obj)方法则是在父元素的最前面添加一个子元素，appendTo($obj)是把子元素添加到$obj目标父元素的末尾，prependTo($obj)则是添加到父元素的开头，after($obj)（在某个元素的后面添加新的兄弟元素，其中$obj是创建的节点），before($obj)（在前面添加兄弟元素）;3、此外，还有一些操作节点的方法：empty()方法（清空调用该方法的元素中的所有节点），remove()（移除调用该方法的元素），clone()（生成一个调用该方法的元素的副本，包含了所有的节点，就是包含标签，内容，属性）"
	},
	"__v": 0
}, {
	"_id": "5e80b56692a5df27084f9d9b",
	"cr": "7.6",
	"col": 7,
	"row": 6,
	"keyword": "jQuery",
	"msg": {
		"title": "特殊属性的操作",
		"content": "1、val(str)方法用来操作value属性的值，当传入参数的时候，调用该方法的元素的value值会发生改变，当不传入参数的时候，会获取调用该方法的元素的value值；2、text(str)方法可以用来操作文本内容，和val类似，传入参数的时候会覆盖文本内容，没有参数就会获取相应的文本内容；3、html(str)方法和text(str)类似，不过html()方法不传入参数会获取文本内容，当传入参数的时候，html()方法能够识别标签；4、scrollTop(num)方法可以用来操作元素的滚动条在垂直方向上的数值，当没有参数的时候，会直接获取滚动条在垂直方向上的数值，传入参数的时候会设置滚动条的位置；5、scrollLeft(num)方法是用来操作元素滚动条在水平方向上的数值；6、offset({})方法会操作调用该方法的元素相当于文档流的偏移，当没有参数的时候，会获取一个对象（通过对象的left和top属性来获取边偏移），而传入一个对象参数就能操作能够元素的边偏移；6、position()方法是获取对象相对于父元素的边偏移，同样获取的是一个对象，但是这个方法获取的数据时一个只读的数据，也就是说不能通过这个方法更改元素的边偏移"
	},
	"__v": 0
}, {
	"_id": "5e80bacb92a5df27084f9d9c",
	"cr": "7.7",
	"col": 7,
	"row": 7,
	"keyword": "jQuery",
	"msg": {
		"title": "JQ绑定事件",
		"content": "JQ中使用on()方法来为元素绑定事件，这其中涉及到了委托事件（动态绑定事件的基础）；1、单独的绑定事件：on('click',fn)；2、委托事件的注册方式：on('click','selector',fn)（委托事件其实是为调用该方法的元素绑定了一个委托事件，但是这个事件的执行对象是当前元素的子元素，通过事件冒泡，委托事件会被给与子元素，但是子元素并没有绑定任何的事件，所以这种方式可以实现事件的动态绑定）；3、on('type','selector',data,fn)方法就是JQ实现所有事件绑定的基础，其中type参数是事件类型，selector是委托事件时候需要被给予注册事件的子元素，data是用来传入数据的参数，如果使用它，可以在事件对象e.data中查看这些数据，fn就是事件触发的时候调用的函数，如果需要使用data中传入的数据，需要写入参数e作为事件对象；4、事件的解绑：off('type')，这个方法在没有参数的时候会解除调用元素上的所有事件，而传入参数后，就会解除调用元素相应类型的事件；5、主动触发事件：trigger('type')，它会触发调用元素上指定的类型的事件"
	},
	"__v": 0
}, {
	"_id": "5e80bc6f92a5df27084f9d9d",
	"cr": "7.8",
	"col": 7,
	"row": 8,
	"keyword": "jQuery",
	"msg": {
		"title": "事件对象",
		"content": "在JQ中，事件对象经常用来阻止标签的默认行为：1、e.stopPropagation()来阻止相应元素的事件冒泡；2、e.preventDefault()来阻止标签的默认行为（一般是超链接标签的页面跳转），此外还有一个省力的方式，使用return|false在事件函数中，就能阻止事件冒泡和默认行为；3、事件对象的其他作用：事件对象中存储了事件触发时候的大量信息，包括但不限于（offsetX：距离父对象的横坐标，clientX：卷曲的横坐标，pageX：相对于浏览器的横坐标）"
	},
	"__v": 0
}, {
	"_id": "5e80bf8a92a5df27084f9d9e",
	"cr": "7.9",
	"col": 7,
	"row": 9,
	"keyword": "jQuery",
	"msg": {
		"title": "JQ中的补充点",
		"content": "1、在JQ中封装了新的鼠标进入和离开事件，mouseenter事件和mouseleave事件，它们不会检测元素的内外边距以及边框，也就是只检测内容；2、JQ中的显著特点就是链式编程，大部分的JQ代码都可以通过点语法一直编写下去，这是因为大部分的方法都具有一个返回值，而这个返回值指向的是调用该方法的对象，但是，有些方法会返回一个新的对象，比如siblings()方法，它返回的是一个数组新对象，这是为了使链式编程继续下去，可以使用end()方法来返回上一个对象，继续进行链式编程（但是链式编程很麻烦，要一直不停的换行才不会导致逻辑紊乱，所以不建议使用end()方法）；3、JQ中获取元素的宽度：width()（获取内容的宽度），innerWidth()（获取内容+左右内边距），outerWidth()（内容+左右内边距+左右边框），outerWidth(true)（内容+左右内边距+左右边框+左右外边距）；4、each(fn)方法，类似数组的foreach()方法，它会遍历数组jq对象中的每一个对象，然后让它们执行fn内部的代码；5、delay(num)方法，设定方法延迟执行的时间，经常用在JQ动画中，实现动画的延时执行，num参数传入的是毫秒数；6、$.noConflict()方法代表的就是jQuery整个函数本身，默认下$符号也代表了jQyery整个函数，但是有些时候需要释放$符号，所以通过把$.noConflict()赋值给一个新的变量就能做到这一点"
	},
	"__v": 0
}]
